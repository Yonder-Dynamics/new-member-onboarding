# Style

Programming style is very important when developing large systems, as it
reduces the cost of collaboration and makes code easy to scale and extend. Our
definition of style includes both the written form of the code itself, and the
decisions made during its design

## The Twelve-Factor App

This [website](https://12factor.net/) is a great starting place for large scale
system design. We won't repeat the article contents here, but we will reiterate
that a developmer-friendly and fast-moving code base starts with these simple
policies. These practices are widely used in industry, and many cutting edge
tools such are designed to support organizations using this design approach.

## Code Style

Good programming style makes your code easy to understand and modify. Here are
some general tips:

### Explicitly scope variables
Though it can be tedious, including explicit
scope with your variables makes it much easier for new developers to trace
through your code and understand it more quickly. This policy is especially
important to follow, as its effects on manifest after the fact. Code that
makes heavy use of implicit imports and variables (`import * from module`)
becomes difficult to maintain once the original author leaves, at which
point much of the implicit information becomes hidden.

### Use a linter
Code linting keeps the codebase consistent, and can help
you catch errors before compile or run time. Maintaining visually
consistently code makes it easier for developers to jump between projects
quickly, and in general improves the apparent quality of our (completely 
open source) code base, if you want to link it on your resume. Linters are
per-language, and should be decided upon beforehand if one has not yet been
selected for the language of your new project.

### Isolate side effects
Side effects are changes made to the external
environment by a function call. An example would be a C function returning
void, and writing its result to a passed-in pointer or global variable.
Side effects make your code difficult to test consistently and
automatically, because the testing framework must also capture the code's
side effects. Where possible, a functional programming approach should be
applied: all work done by a function should be included in its return
value(s). Conducting IO, such as printing to `stdout`, storing values in
a database, etc, should only be done in functions explicitly marked as
IO functions, and which should ideally exist only at the top level of a
module's executable. Functions which would normally execute these side
effects should instead include all information necessary to execute the IO
in their return value, and allow the caller to complete the IO. This way,
a unit test can verify the behavior of the code simply by checking the IO
configuration generated by a function call. Keeping the actual execution
of IO at the top level of an executable makes most of the codebase
accessable to unit testing, and also makes it easier to reconfigure or
redirect the IO. Here is an example architecture taking advantage of this
design approach:
1. Parsing Layer
    The top level of an executable should only process command line arguments.
    These arguments should be organzied into the generic config format expected
    by the Configuration Layer descibed below. This layer could also read
    configuration from a config file, again targeting the generic format
    expected by the Configuration Layer. This layer should not do anything
    except parsing and organizing configuration, or else these is risk of
    duplicating functionality if new sources of configuration are added later.
2. Configuration Layer
    The configuration layer takes a generic configuration object (ex: a python
    dict) that determines the value of some dynamic elements of the program's
    behavior. This design allows for the source of configuration to easily be
    changed for different use cases or extensions, without invasive code
    changes or new testing to verify consistent behavior. With the
    complete config information information provided by the layer above, this
    layer should have all the information it needs to set up files and network
    connections necessary to perform the program's job. This layer organizes
    all of the side effects of a program, and is a good target for unit testing
    to redirect IO to verification routines. An example of the Configuration
    Layer would a function that, given the URL of a Redis instance and the name
    of the client, creates a connection pool to the given URL and passes it
    down to the IO layer to use.
4. IO Layer
    This is the beginning of the  the "business logic" of the program. This
    layer executes function calls into the Logic Layer, and routes return
    values to the external environment using generic connection objects such as
    _clients_ or _sessions_ provided by the Configuration layer. A typical IO
    Layer should collect information from the provided connection abstractions,
    route information to the Logical Layer, then route the returned values to
    additional funciton calls or to an extenal store via connection objects. An
    example of the IO layer would be a function that waits for incoming
    messages on a Redis topic, parses information out of the message, passes
    the information to a function, then serializes the returned information
    and writes it to another Redis topic.
5. Logic Layer
    This is the rest of the "business logic". All functions in the Logic Layer
    must be stateless and contain no side effects. The Logic Layer does not
    make use of connections whatsoever; all input is received though the
    function arguments, and all output is contained within the function return
    value. Calls into the Logic Layer are easy to reuse and reconfigure,
    without having to worry about managing unwanted external changes or
    inconsistent behavior. The logic layer is entirely deterministic, making
    unit testing simple and powerful. An example of the logic layer is the
    inverse kinematics portion of a robot arm position solver, which takes
    a complete description of the robot arm, including its current position and
    the target position. This code can easily be tested by changing the arm
    description, and checking that the return value matches the expected value.